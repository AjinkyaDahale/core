/****************************************************************************** 

  (c) 2004-2016 Scientific Computation Research Center, 
      Rensselaer Polytechnic Institute. All rights reserved.
  
  This work is open source software, licensed under the terms of the
  BSD license as described in the LICENSE file in the top-level directory.
 
*******************************************************************************/
#include "pumi.h"
#include <map>
#include <set>
using std::map;
using std::set;


char _string_enttype[][10] = {"VERTEX", "EDGE", "FACE", "REGION", "ALLTYPE"};
char _string_noyes[][5] = {"NO", "YES"};

void pumi_ghost_delete (pMesh m)
{
}

void pumi_ghost_info (pMesh m, std::vector<int>& ghostinfo)
{
}

void packGhost(mEntity *ent, int dest_partid, int src_partid, 
                void *&msg_send, size_t &msg_size, int meshDim);
pMeshEnt unpackGhost(mPart* part, int meshDim, void *msg_recv, std::vector<rc_struct_3>& entitiesToBounce, int*);

void collectEntitiesToGhost (int, int, 
             std::map<pMeshEnt,int>* entitiesToGhost);

void  printPtnObjToGhost (std::map<pMeshEnt, std::vector<pMeshEnt> >& brg_ghost_map);   
void exchangeEntitiesToGhost(int mesh_dim, int ent_dim, std::map<pMeshEnt,int>& entities_to_ghost, int* num_ghost); 
void sendGhostToOwner(std::vector<rc_struct_3>& entitiesToBounce);
typedef std::map<int, pMeshEnt> ghostCopyMap;

// *****************************************
void copy_RC_to_BP(pMeshEnt src_ent, int dest_dim, pMeshEnt dest_ent)
// *****************************************
{
 // copy source entity's remote copy to dest entity's tempBPs
    pCopies remotes;
    pumi::instance()->mesh->getRemotes(src_ent,remotes);
    APF_ITERATE(pCopies,remotes,rit)
      pumi::instance()->bps_map[dest_dim][dest_ent].insert(rit->first);
}

// *****************************************
void copy_BP_to_BP(int src_dim, pMeshEnt src_ent, int dest_dim, pMeshEnt dest_ent)
// *****************************************
{ // copy source entity's tempBPs to dest entity's tempBPs
  for (set<int>::iterator bpiter=bps[src_dim][src_ent].begin();bpiter!=bps[src_dim][src_ent].end();++bpiter)
    pumi::instance()->bps_map[dest_dim][dest_ent].insert(*bpiter);
}

// **********************************************
pMeshEnt ent_getGhost(pMeshEnt ent, int pid)
// **********************************************
{
  pMeshEnt remoteEnt = (pMeshEnt)0;

  if(ent->theGhostCopies==NULL)
   return remoteEnt;

  std::map<int,pMeshEnt>::iterator mapit = ent->theGhostCopies->find(pid);
  if (mapit!=ent->theGhostCopies->end())
    remoteEnt = mapit->second;
  return remoteEnt;
}


// **********************************************
void ent_addGhost(pMeshEnt ent, int pid, pMeshEnt remoteEnt)
// **********************************************
{
  if(ent->theGhostCopies==NULL)
   ent->theGhostCopies = new ghostCopyMap;
  ent->theGhostCopies->insert(ghostCopyMap::value_type(pid, remoteEnt));
}

// **********************************************
void ent_deleteGhost(pMeshEnt ent, int pid)
// **********************************************
{
  if(ent->theGhostCopies==NULL)
     return;

  ent->theGhostCopies->erase(ghostCopyMap::key_type(pid));

  if(ent->theGhostCopies->empty())
     SAFE_DELETE(ent->theGhostCopies);
}

// **********************************************
void ent_clearGhost(int ent_dim, pMeshEnt e)
// **********************************************
{
  ghost_map[ent_dim][e].clear();
}

// **********************************************
int delete_ghost()
// **********************************************
{
  pMeshEnt e;
  pMesh m = pumi::instance()->mesh;
  std::vector<pMeshEnt> ghost_ents[4];
  int mesh_dim=pumi_mesh_getdim(m), ghost_index;

  for (int dim=mesh_dim; dim>=0; --dim)
  {
    pMeshIter it = m->begin(dim);
    while ((e = m->iterate(it)))
    {
      pumi::instance()->bps_map[dim][e]->clear();
      if ((*ent_it)->getAttachedInt (FMDB_Util::Instance()->getGhost(), &ghost_index) && ghost_index!=-1)
        ghost_ents[dim].push_back(e); // collect ghost copies per dimension
    }
    m->end(it);
  }
 
  PCU_Comm_Begin();
  size_t msg_size = sizeof(pMeshEnt)+sizeof(int);
  void* msg_send = malloc(msg_size);
  pMeshEnt* s_ent;
  pMeshEnt ent; 
  int* s_id; 

  for (int i=mesh_dim; i>=0; --i)  // region to vertex
  {
    for (std::vector<pMeshEnt>::iterator eiter= ghost_ents[i].begin(); eiter!=ghost_ents[i].end();++eiter) 
    {
      ent = *eiter; 
      ent->getAttachedInt (FMDB_Util::Instance()->getGhost(), &ghost_index); // ghost index is the owner part id
      // send message to owner copy
      {
	s_ent = (pMeshEnt*)msg_send; 
	*s_ent = ent_getGhost(ent, ghost_index);
	s_id = (int*)((char*)msg_send+sizeof(pMeshEnt)); 
        *s_id = mesh->getPart(0)->getId();   // ghost partid
        PCU_Comm_Write(ghost_index/mesh->getNumPart(), (void*)msg_send, msg_size);  // send message to owner copy
      }

      // send message to non-owner remote copy
      if (ent->getNumRemoteCopies())
      {
        for (mEntity::RCIter rcIter=ent->rcBegin(); rcIter!=ent->rcEnd();++rcIter)
        {
	  s_ent = (pMeshEnt*)msg_send; 
	  *s_ent = rcIter->second;
	  s_id = (int*)((char*)msg_send+sizeof(pMeshEnt)); 
	  *s_id = mesh->getPart(0)->getId();   // ghost partid
          PCU_Comm_Write((rcIter->first)/mesh->getNumPart(), (void*)msg_send, msg_size);
        }
      }
    }
  }
  PCU_Comm_Send();
  free(msg_send);

  // receive phase begins
  void *msg_recv;
  int pid_from;
  while(PCU_Comm_Read(&pid_from, &msg_recv, &msg_size))
  {
    s_ent = (pMeshEnt*)msg_recv;
    s_id = (int*)((char*)msg_recv+sizeof(pMeshEnt)); 
    ent_deleteGhost(*s_ent, *s_id);
  }

  for (std::vector<pMeshEnt>::iterator ghost_iter=ghost_ents[PUMI_REGION].begin(); ghost_iter!=ghost_ents[PUMI_REGION].end();++ghost_iter)
    M_removeRegion(mesh->getPart(0), *ghost_iter);
      
  for (std::vector<pMeshEnt>::iterator ghost_iter=ghost_ents[PUMI_FACE].begin(); ghost_iter!=ghost_ents[PUMI_FACE].end();++ghost_iter)
  {
#ifdef DEBUG
    assert((*ghost_iter)->size(PUMI_REGION)==0);
#endif
    M_removeFace(mesh->getPart(0), *ghost_iter);
  }

  for (std::vector<pMeshEnt>::iterator ghost_iter=ghost_ents[PUMI_EDGE].begin(); ghost_iter!=ghost_ents[PUMI_EDGE].end();++ghost_iter)
  {
#ifdef DEBUG
    assert((*ghost_iter)->size(PUMI_FACE)==0);
#endif
    M_removeEdge(mesh->getPart(0), *ghost_iter);
  }

  for (std::vector<pMeshEnt>::iterator ghost_iter=ghost_ents[PUMI_VERTEX].begin(); ghost_iter!=ghost_ents[PUMI_VERTEX].end();++ghost_iter)
  {
#ifdef DEBUG
    assert((*ghost_iter)->size(PUMI_EDGE)==0);
#endif
    M_removeVertex(mesh->getPart(0), *ghost_iter);
  }
  return PUMI_SUCCESS;
}

char _string_enttype[][10] = {"VERTEX", "EDGE", "FACE", "REGION", "ALLTYPE"};
char _string_noyes[][5] = {"NO", "YES"};
 

// *****************************************
void pumi_ghost_create (pMesh m,int bridge_dim, int ghost_dim, int num_layer, bool include_copy)
// *****************************************
{
  int mesh_dim = pumi_mesh_getdim(m);

  // brid/ghost dim check
  if (bridge_dim>=ghost_dim || 0>bridge_dim || bridge_dim>=mesh_dim || ghost_dim==0||ghost_dim>mesh_dim)
  {
    if (!pumi_rank()) std::cout<<"[pumi error] "<<__func__<<": invalid input - ghost_dim "<<ghost_dim<<", bridge_dim "<<bridge_dim<<"\n";
    return;
  }

#ifdef DEBUG
  double cur_time, prev_time=pumi_gettime();
  double cur_mem, prev_mem=pumi_getmem();
  double begin_time=prev_time, begin_mem=prev_mem;
#endif

  pMeshEnt brg_ent;

  int ghost_partid, check_mark, ent_count;

// ********************************************
// STEP 1: compute entities to ghost
// ********************************************
  pMeshEnt ghost_ent;
  pMeshEnt e;
  std::map<pMeshEnt,int> entities_to_ghost[4];
  std::vector<pMeshEnt> adj_ent;
  std::vector<pMeshEnt> processed_ent;

  pTag ghost_copy_tag = m->findTag("ghost copy");
  if (!ghost_copy_tag) 
    ghost_copy_tag = m->createIntTag("ghost copy", 1);
  pTag check_mark_tag = m->findTag("check mark");
  if (!check_mark_tag) 
    check_mark_tag = m->createIntTag("check mark", 1);

  int one=1;
  pMeshIter pbdry_iter = m->begin(bridge_dim);
  while ((e = m->iterate(pbdry_iter)))
  {
    if (!(pumi::instance()->mesh->isShared(e))) continue; // internal ent

    if (!include_copy && m->getOwner(e)!=pumi_rank()) continue;

    bps[bridge_dim][e].clear(); //brg_ent->clearBPs();
    processed_ent.clear();
    adj_ent.clear();

    apf::Adjacent adjacent;
    m->getAdjacent(e,ghost_dim,adjacent);    
    *num_adj_ent = adjacent.getSize();

    for (int i=0; i<*num_adj_ent; ++i)
    {
      if (m->hasTag(adjacent[i], ghost_copy_tag)) continue; // skip ghost copy

      ghost_ent = adjacent[i];
      ent_count = entities_to_ghost[ghost_dim].count(ghost_ent);
      if (!ent_count)
      {
        bps[ghost_dim][pumi_ment_getid(ghost_ent)].clear(); // ghost_ent->clearBPs()
        entities_to_ghost[ghost_dim][ghost_ent]=PCU_Comm_Self();    // source partid
      }
      copy_RC_to_BP(brg_ent, ghost_dim, ghost_ent);
      m->setIntTag(ghost_ent, check_mark_tag, &one); 
      processed_ent.push_back(ghost_ent);
    }
    
    //for (std::vector<pMeshEnt>::iterator ghost_it=brg_ghost_map[ent]->begin();ghost_it!=brg_ghost_map[ent]->end(); ++ghost_it)
//    std::cout<<"[p"<<PUMI_CommRank()<<"] "<<PUMI_MeshEnt_StrID(brg_ent)<<"- 1-layer ghost "<<processed_ent.size()<<"\n";
    int start_prev_layer=0, size_prev_layer=processed_ent.size(), num_prev_layer;
    for (int layer=2; layer<num_layer+1; ++layer)
    {  
      num_prev_layer=0;
      for (int i=start_prev_layer; i<size_prev_layer; ++i)
      {
        ghost_ent = processed_ent.at(i);
        adj_ent.clear();
        pumi_ment_get2ndadj (ghost_ent, bridge_dim, ghost_dim, adj_ent)
        
        for (std::vector<pMeshEnt>::iterator adj_ent_it=adj_ent.begin(); adj_ent_it!=adj_ent.end(); ++adj_ent_it)
        {
          e = *adj_ent_it; 
          if (m->hasTag(e, ghost_copy_tag) || m->hasTag(e, check_mark_tag))
            continue; // skip ghost copy or already-processed copy
      
          ent_count = entities_to_ghost[ghost_dim].count(e);
          if (!ent_count)
          {
            e->clearBPs();
            entities_to_ghost[ghost_dim][e]=PCU_Comm_Self();    // source partid
          }
          copy_RC_to_BP(brg_ent, ghost_dim, e);
          m->setIntTag(e, check_mark_tag, &one); 
          processed_ent.push_back(e);
          ++num_prev_layer;
#ifdef SEOL
          ++count;
#endif          
        } // for (std::vector<pMeshEnt>::iterator adj_ent_it=adj_ent.begin()
      } // for int i=start_prev_layerghost_it
      start_prev_layer+=size_prev_layer;
      size_prev_layer+=num_prev_layer;
    } // for layer

    for (std::vector<pMeshEnt>::iterator ghost_it=processed_ent.begin(); ghost_it!=processed_ent.end(); ++ghost_it)
      m->removeTag(*ghost_it, check_mark_tag);
  } // while brg_ent
  m->end(pbdry_iter);

  collectEntitiesToGhost(m, bridge_dim, ghost_dim, entities_to_ghost); 

#ifdef DEBUG
  cur_mem = pumi_getmem();
  cur_time = pumi_gettime();
  pumi_showtimemem("collecting entities to ghost...", cur_time-prev_time, cur_mem-prev_mem);
  prev_time=cur_time;
  prev_mem=cur_mem;
#endif

// ********************************************
// STEP 2: Migrate entities
// ********************************************
  int num_ghost=0;
  for (int i=0; i<=ghost_dim;++i) 
    exchangeEntitiesToGhost(mesh, mesh_dim, i, entities_to_ghost[i], &num_ghost);

#ifdef DEBUG
  cur_mem =  pumi_getmem();
  cur_time =  pumi_gettime();
  PUMI_DspRsrc("exchanging entities for ghosting...", cur_time-prev_time, cur_mem-prev_mem);
  int global_num_ghost=0;
  MPI_Allreduce(&num_ghost,&global_num_ghost, 1, MPI_INT,MPI_SUM,MPI_COMM_WORLD);
  if (!pumi_rank())
    std::cout<<"\nGHOSTING: Time="<<cur_time-begin_time<<" (sec), Mem="<<cur_mem - begin_mem<<" (MB) "
             <<"# ghost created="<<global_num_ghost<<" (brg_type="<<_string_enttype[bridge_dim]<<", ghost_type="<<_string_enttype[in_ghost_dim]<<", #layer="<<num_layer
             <<", include_copy="<<_string_noyes[include_copy]<<")\n\n";
#endif
  return PUMI_SUCCESS;
}

// *****************************************
void collectEntitiesToGhost (int bridge_dim, int ghost_dim, 
                             std::map<pMeshEnt,int>* entitiesToGhost)
// *****************************************
{    
  pMeshEnt down_ent, *remote_ent;
  int ent_count;
  std::vector<pMeshEnt> DownEnts;
  DownEnts.resize(27);
  pMeshEnt ghost_ent;
  
  // SEOL: this should be fixed
  for (std::map<pMeshEnt, int>::const_iterator ghost_it=entitiesToGhost[ghost_dim].begin(); ghost_it!=entitiesToGhost[ghost_dim].end(); ++ghost_it)
  {
    ghost_ent=ghost_it->first;    
    ghost_ent->attachInt (FMDB_Util::Instance()->getGhost(), -1);
    DownEnts.clear();
    getDownEntities(ghost_ent, DownEnts);
  
    for (std::vector<pMeshEnt>::iterator downadj_it=DownEnts.begin();downadj_it!=DownEnts.end();++downadj_it)
    {
      down_ent = *downadj_it;
      ent_count = entitiesToGhost[down_ent->getLevel()].count(down_ent);
      if (!ent_count)
        down_ent->clearBPs();
      entitiesToGhost[down_ent->getLevel()][down_ent]=mesh->getPart(0)->getId();         // src local pid
      copy_BP_to_BP(ghost_ent, down_ent);
      down_ent->attachInt (FMDB_Util::Instance()->getGhost(), -1);
    }
  } // for std::vector<pMeshEnt>::iterator ghost_it

  // do communication to unify BP
  PCU_Comm_Begin();
  void* msg_send;
  pMeshEnt* s_ent;
  int* s_id; 

  std::map<pMeshEnt, int>::iterator eit;
  size_t msg_size;
  int numBP;
  pMeshEnt ent;
  for (int dim = 0; dim <=ghost_dim; ++dim)
  {
    for (eit=entitiesToGhost[dim].begin();eit!=entitiesToGhost[dim].end();++eit)
    {
      ent = eit->first;
      if (ent->getNumRemoteCopies()==0)
        continue;

      numBP = ent->getNumBPs();
      for (mEntity::RCIter rciter=ent->rcBegin();rciter!=ent->rcEnd();++rciter)
      {
        msg_size=sizeof(pMeshEnt) +sizeof(int) + numBP*sizeof(int);
        msg_send = malloc(msg_size);
        
        s_ent = (pMeshEnt*)msg_send; 
        s_id = (int*)((char*)msg_send+sizeof(pMeshEnt));
	
        *s_ent = rciter->second; 
        *s_id = rciter->first; 

        int *BPs = (int*)((char*)msg_send + sizeof(pMeshEnt) + sizeof(int));
        int i = 0;
        for (mEntity::BPIter bpiter=ent->bpBegin();bpiter!=ent->bpEnd();++bpiter)
        {
          BPs[i]=*bpiter;
          i++;
        }
        PCU_Comm_Write((rciter->first)/mesh->getNumPart(), (void*)msg_send, msg_size);
        free(msg_send);     
      }
    }
  }
  PCU_Comm_Send();
  
  // receive phase
  void *msg_recv;
  int pid_from;
  int* BPs;
  while(PCU_Comm_Read(&pid_from, &msg_recv, &msg_size))
  {
    remote_ent = *((pMeshEnt*)msg_recv); 

    int* remote_partid = (int*)((char*)msg_recv+sizeof(pMeshEnt)); 
    BPs = (int*)((char*)msg_recv+sizeof(pMeshEnt)+sizeof(int)); 
    numBP = (msg_size-sizeof(pMeshEnt)-sizeof(int)) /sizeof(int);

    if (!entitiesToGhost[remote_ent->getLevel()].count(remote_ent))
      remote_ent->clearBPs();
    entitiesToGhost[remote_ent->getLevel()][remote_ent] = *remote_partid;

    for (int i = 0; i < numBP; i++)
      remote_ent->addBPs(BPs[i]);
  }

#ifdef _DEBUG_
  for (int dim = 0; dim <= ParUtil::Instance()->get_maxMeshDim(); ++dim)
    for (eit=entitiesToGhost[dim].begin();eit!=entitiesToGhost[dim].end();++eit)
      eit->first->printBPs(eit->second);
#endif
}

// **********************************************
void exchangeEntitiesToGhost(int meshDim, int entDim,
                     std::map<pMeshEnt,int>& entitiesToExchg, int* num_ghost)	  
// **********************************************
{
  pMeshEnt ent;
  std::set<int>::iterator piter;
  int src_partid, dest_partid,owner_partid;
  size_t msg_size; 
  void *msg_send;

  std::map<pMeshEnt, int>::const_iterator eit; 
  std::map<int, pMeshEnt>::iterator rcIter; 

  PCU_Comm_Begin();

  std::set<int> RCs, res_parts, temp; 
  std::set<int>::iterator bpIter; 
  for(eit=entitiesToExchg.begin(); eit!=entitiesToExchg.end();++eit)
  {
    ent = eit->first; 
    src_partid = eit->second;             // current global pid

    res_parts.clear(); 
    temp.clear(); 
    if (ent->getNumRemoteCopies()) // let the owner part send the ghost copy
    {
      for (mEntity::RCIter rciter=ent->rcBegin();rciter!=ent->rcEnd();++rciter)
        res_parts.insert(rciter->first);
      res_parts.insert(src_partid);

      PUMI_MeshEnt_GetOwnPartID(ent, mesh->getPart(src_partid/mesh->getNumPart()), &owner_partid);
      if (src_partid!=owner_partid)
      {
#ifdef _DEBUG_
    std::cout<<"["<<PUMI_CommRank()<<"] "<<__func__<<" skip sending "<<PUMI_MeshEnt_StrID(ent)<<"- src_partid="<<src_partid<<", owner partid="<<owner_partid<<"\n";
#endif
        continue; // move onto the next entity to exchange
      }
    }

    if (ent->theGhostCopies!=NULL)
      for (std::map<int,pMeshEnt>::iterator ghost_it = ent->theGhostCopies->begin(); ghost_it!= ent->theGhostCopies->end(); ++ghost_it)
        res_parts.insert (ghost_it->first);

    set_subtract(*(ent->tempBPs),res_parts, temp);

    for (piter=temp.begin(); piter!=temp.end();++piter)
    {	      
      dest_partid = *piter; 
      if (dest_partid==src_partid) continue;
      int dest_proc = dest_partid/mesh->getNumPart();
      packGhost(mesh, ent, dest_partid, src_partid, msg_send, msg_size, meshDim);
      PCU_Comm_Write(dest_proc, msg_send, msg_size);
      free(msg_send); 
      packTagData(mesh,ent,dest_proc);
    }
  }
  PCU_Comm_Send();

   // receive phase begins
  void *msg_recv;
  int pid_from;
  mPart* dest_part; 
  std::vector<rc_struct_3> entitiesToBounce;

  while (PCU_Comm_Read(&pid_from, &msg_recv, &msg_size))
  {
    // get the dest part id
    int* tmp_ptr = (int*)msg_recv;  
    dest_partid = *tmp_ptr;     
    dest_part = mesh->getPart(dest_partid%mesh->getNumPart()); 	
    pMeshEnt ghost =
        unpackGhost(dest_part, meshDim, msg_recv, entitiesToBounce, num_ghost);
    unpackTagData(mesh,ghost);
  }

  sendGhostToOwner(entitiesToBounce);
}

// **********************************************
void sendGhostToOwner(std::vector<rc_struct_3>& entitiesToBounce)
// **********************************************
{
  size_t msg_size = sizeof(int)+2*sizeof(pMeshEnt);
  PCU_Comm_Begin();
  void* msg_send = malloc(msg_size);

  std::vector<rc_struct_3>::const_iterator rcvIter;
  for (rcvIter=entitiesToBounce.begin(); rcvIter!=entitiesToBounce.end();++rcvIter)
  { 
    pMeshEnt* s_ent = (pMeshEnt*)msg_send; 
    s_ent[0] = rcvIter->src_ent;  // new_ent
    s_ent[1] = rcvIter->dest_ent; // sender entity
    int* s_id = (int*)((char*)msg_send+sizeof(pMeshEnt)*2);  
    *s_id = rcvIter->src_partid; // new_ent partid
    PCU_Comm_Write(rcvIter->dest_partid/(ParUtil::Instance()->getTgtNumParts()), msg_send, msg_size);

    if (rcvIter->src_ent->getNumRemoteCopies())
    {
      for (mEntity::RCIter rciter=rcvIter->src_ent->rcBegin();rciter!=rcvIter->src_ent->rcEnd();++rciter)
      {
        pMeshEnt* s_ent = (pMeshEnt*)msg_send; 
        s_ent[0] = rcvIter->src_ent;  // new_ent
        s_ent[1] = rciter->second; // sender entity
        int* s_id = (int*)((char*)msg_send+sizeof(pMeshEnt)*2);  
        *s_id = rcvIter->src_partid; // new_ent partid
        PCU_Comm_Write(rciter->first/(ParUtil::Instance()->getTgtNumParts()), msg_send, msg_size);
      }
    }
  }

  PCU_Comm_Send();
  free(msg_send);

  // receive phase begins
  void *msg_recv;
  int pid_from;
  while(PCU_Comm_Read(&pid_from, &msg_recv, &msg_size))
  {
    pMeshEnt* s_ent = (pMeshEnt*)msg_recv;
    int* s_id = (int*)((char*)msg_recv+sizeof(pMeshEnt)*2); 
    ent_addGhost(s_ent[1],*s_id, s_ent[0]);
#ifdef _DEBUG_
    std::cout<<"["<<PUMI_CommRank()<<"] "<<__func__<<" "<<PUMI_MeshEnt_StrID(s_ent[1])<<"->addGhost ("
      <<*s_id<<", "<<s_ent[0]<<")\n";
#endif
  }
}



// **********************************************
void packGhost(pMeshEnt ent, int dest_partid, int src_partid, 
                void *&msg_send, size_t &msg_size, int meshDim)
// **********************************************
{ 
  int entity_size;

  short int numRC = ent->getNumRemoteCopies();
  short int entDim = ent->getLevel();
  short int numDE = entDim+1;

  entity_size = 2*sizeof(int) + sizeof(packedEnt) + numRC*(sizeof(int)+sizeof(pMeshEnt));

  int n_bytes = 0;

  pGeomEnt gent = ent->getClassification();
  short int numParam=0, gType;
  int gTag;

  if(gent!=0) {
    gType = GEN_type(gent);
    gTag = GEN_tag(gent);
  }
  else{
    gTag = 1;
    gType = 3;
  }

  if (entDim == PUMI_VERTEX)
  {
    if (ent->getData(FMDB_Util::Instance()->getParametric()))
    {
      if (gType==1) // vertex classified on model edge
        numParam=1;
      else if (gType==2) // vertex classified on model face
        numParam=2;
    }

    entity_size += sizeof(packedVertex) + numParam*sizeof(double);

    msg_size = entity_size;
    msg_send = malloc(msg_size);

    // dest global pid and src local pid 
    int* tmp_pid; 
    tmp_pid = (int*)msg_send; 
    tmp_pid[0]=dest_partid; 
    tmp_pid[1]=src_partid; 
    n_bytes += 2*sizeof(int); 

    // fixed length data
    packedEnt *entbuf = (packedEnt*)((char*)msg_send + n_bytes);
    entbuf->numDE = numDE;
    entbuf->sender = ent;
    entbuf->gTag = gTag;
    entbuf->gType = gType;
    entbuf->numRC = numRC;
    entbuf->numBP = 0;

    n_bytes += sizeof(packedEnt);

    // vertex specific parameters
    packedVertex *castbuf = (packedVertex*)((char*)msg_send + n_bytes);
    castbuf->iD = ent->getId();

    double xyz[3];
    ((mVertex*)ent)->getCoord(xyz[0], xyz[1], xyz[2]);
    for(int i=0;i<3;i++) 
       castbuf->coord[i] = xyz[i]; 
    castbuf->numParam = numParam;
    n_bytes += sizeof(packedVertex);

    if (numParam > 0)
    {
      double *Params = (double*)((char*)msg_send + n_bytes);
      SCOREC::Util::mVector vec = ent->getAttachedVector(FMDB_Util::Instance()->getParametric());
      for (int k=0; k<numParam;++k) 
      {
        Params[k] = vec(k);
      }
      n_bytes += numParam*sizeof(double);
    }
  }
  else
  {
    numDE = ent->size(0); 
    entity_size += sizeof(short int) + numDE*sizeof(pMeshEnt);   
    if (meshDim==ent->getLevel()) 
      entity_size += sizeof(double); /* weight*/

    msg_size = entity_size;
    msg_send = malloc(msg_size);

    // dest global pid and src local pid
    int* tmp_pid;
    tmp_pid = (int*)msg_send;
    tmp_pid[0]=dest_partid;
    tmp_pid[1]=src_partid;
    n_bytes += 2*sizeof(int); 

    // fixed length data
    packedEnt *entbuf = (packedEnt*)((char*)msg_send + n_bytes);
    entbuf->numDE = numDE;
    entbuf->sender = ent;
    entbuf->gTag = gTag;
    entbuf->gType = gType;
    entbuf->numRC = numRC;
    entbuf->numBP = 0;
    n_bytes += sizeof(packedEnt);

    short int *type = (short int*)((char*)msg_send + n_bytes);
    *type = ent->getType();
    n_bytes += sizeof(short int);
 
    pMeshEnt* DEs = (pMeshEnt*)((char*)msg_send + n_bytes);
    for (int i=0; i<numDE;++i)
    {
      if (ent->get(0,i)->getRemoteCopy(dest_partid))
        DEs[i] = ent->get(0,i)->getRemoteCopy(dest_partid);
      else
        DEs[i] = ent_getGhost(ent->get(0,i),dest_partid);

      if (DEs[i]==NULL) 
        std::cout<<"["<<PUMI_CommRank()<<"] part "<<src_partid<<" - PUMI FATAL ERROR in creating "<<PUMI_MeshEnt_StrID(ent)
                 <<" on part "<<dest_partid
                 <<" due to "<<PUMI_MeshEnt_StrID(ent->get(0,i))<<" NOT EXISTING on dest part "<<dest_partid<<std::endl;
    }
    n_bytes += numDE*sizeof(pMeshEnt);
  }

  // variable length data - Remote copy
  if (numRC>0)
  {
    int *remote_partid;
    mEntity **RCs_ent;
    for (mEntity::RCIter rciter=ent->rcBegin();rciter!=ent->rcEnd();++rciter)
    {
      remote_partid = (int*)((char*)msg_send + n_bytes);
      *remote_partid = rciter->first;
      n_bytes += sizeof(int);
      RCs_ent = (pMeshEnt*)((char*)msg_send + n_bytes);
      *RCs_ent = rciter->second;
      n_bytes += sizeof(pMeshEnt);
    }
  }

  if (ent->getLevel()==meshDim)  // weight
  {
     double weight;
     PUMI_MeshEnt_GetWeight(ent, &weight); 
     memcpy((char*)msg_send+n_bytes, &weight, sizeof(double)); //avoid alignment exception on BGP
     n_bytes+=sizeof(double); 
  }
}

// **********************************************
pMeshEnt unpackGhost(mPart* part, int meshDim, void *msg_recv, std::vector<rc_struct_3>& entitiesToBounce, int* num_ghost)
// **********************************************
{
  int n_bytes = 0;
  short int numRC;

  mEntity *new_ent, *sender_copy;

// PRE-STEP: add sender to remote copy and store entity to bounce
  // dest global pid and src local pid 
  int* tmp_pid = (int*)msg_recv; 
  int dest_partid = tmp_pid[0]; 
  int src_partid = tmp_pid[1]; 
  n_bytes += 2*sizeof(int); 

  packedEnt *entbuf = (packedEnt*)((char*)msg_recv + n_bytes);
  n_bytes += sizeof(packedEnt);

  sender_copy = entbuf->sender;
  numRC = entbuf->numRC;
  pGeomEnt geom_ent=part->getGEntity(entbuf->gTag, entbuf->gType);
#ifdef DEBUG
    if (!geom_ent)
      std::cout<<"["<<PUMI_CommRank()<<"] "<<__func__<<" ERROR: src part "<<src_partid<<", dest partid "<<dest_partid<<" failed getting geom ent (type "<<entbuf->gType<<", tag "<<entbuf->gTag<<")\n";
#endif

  if (entbuf->numDE == 1)
  {
    // STEP 1: create entity
    packedVertex *castbuf = (packedVertex*)((char*)msg_recv + n_bytes);
    n_bytes += sizeof(packedVertex);

    new_ent = part->createVertex(castbuf->iD, castbuf->coord[0], castbuf->coord[1], castbuf->coord[2],
                                 geom_ent);
    if (castbuf->numParam > 0)
    {
      double* Params = (double*)((char*)msg_recv + n_bytes);
      if (castbuf->numParam == 1)
        new_ent->attachVector (FMDB_Util::Instance()->getParametric(),SCOREC::Util::mVector(Params[0],0,0));
      else // if (castbuf.numParam==2)
        new_ent->attachVector (FMDB_Util::Instance()->getParametric(),SCOREC::Util::mVector(Params[0],Params[1],0));
      n_bytes += castbuf->numParam*sizeof(double);
    }
  }
  else
  {
    short int *type = (short int*)((char*)msg_recv + n_bytes);
    n_bytes += sizeof(short int);

    // STEP 1: create an entity
    short int numDE;
    pMeshEnt* DEs = (pMeshEnt*)((char*)msg_recv + n_bytes);
    switch (*type)
    {
      case mEntity::EDGE:
      {
        numDE=2;
#ifdef DEBUG
        if (!(mVertex*)DEs[0]) 
          std::cout<<"["<<PUMI_CommRank()<<"] src part "<<src_partid<<", dest partid "<<dest_partid<<" failed getting vertex v1"<<DEs[0]<<std::endl;
        if (!(mVertex*)DEs[1]) 
          std::cout<<"["<<PUMI_CommRank()<<"] src part "<<src_partid<<", dest partid "<<dest_partid<<" failed getting vertex v2"<<DEs[1]<<std::endl;
#endif
        new_ent = M_createE(part, (mVertex*)DEs[0], (mVertex*)DEs[1], geom_ent);
      } break;

      case mEntity::TRI:
      {
        numDE=3;
        pMeshEnt edges[3];
        edges[0]=(pMeshEnt)E_exist((mVertex*)DEs[0],(mVertex*)DEs[1]);
        edges[1]=(pMeshEnt)E_exist((mVertex*)DEs[1],(mVertex*)DEs[2]);
        edges[2]=(pMeshEnt)E_exist((mVertex*)DEs[0],(mVertex*)DEs[2]);
#ifdef DEBUG
        if (!edges[0]) 
          std::cout<<"["<<PUMI_CommRank()<<"] part "<<dest_partid<<" failed getting edge 0 "<<edges[0]<<std::endl;
        if (!edges[1]) 
          std::cout<<"["<<PUMI_CommRank()<<"] part "<<dest_partid<<" failed getting edge 1 "<<edges[1]<<std::endl;
        if (!edges[2]) 
          std::cout<<"["<<PUMI_CommRank()<<"] part "<<dest_partid<<" failed getting edge 2 "<<edges[2]<<std::endl;
#endif
        new_ent = M_createF(part, 3, edges, 0, geom_ent);
      } break;

      case mEntity::QUAD:
      {
	numDE=4; 
	pMeshEnt edges[4];
	edges[0]=(pMeshEnt)E_exist((mVertex*)DEs[0],(mVertex*)DEs[1]);
	edges[1]=(pMeshEnt)E_exist((mVertex*)DEs[1],(mVertex*)DEs[2]);
	edges[2]=(pMeshEnt)E_exist((mVertex*)DEs[2],(mVertex*)DEs[3]);
	edges[3]=(pMeshEnt)E_exist((mVertex*)DEs[3],(mVertex*)DEs[0]);               //does the order of vertex matter?
	new_ent = M_createF(part, 4, edges, 0, geom_ent);	
      } break;

      case mEntity::TET:
      {
        numDE=4;
        pMeshEnt faces[4];    
        faces[0]=(pMeshEnt)F_exist(0,DEs[0],DEs[1],DEs[2],(pMeshEnt)0);
        faces[1]=(pMeshEnt)F_exist(0,DEs[0],DEs[1],DEs[3],(pMeshEnt)0);
        faces[2]=(pMeshEnt)F_exist(0,DEs[1],DEs[2],DEs[3],(pMeshEnt)0);
        faces[3]=(pMeshEnt)F_exist(0,DEs[0],DEs[2],DEs[3],(pMeshEnt)0);
        new_ent=(pMeshEnt)M_createR(part, 4, faces, 0, geom_ent);
      } break;

      case mEntity::HEX: 
      {
	numDE=8; 
		
	pMeshEnt faces[6];
	faces[0]=(pMeshEnt)F_exist(0,DEs[0],DEs[3],DEs[2],DEs[1]);
	faces[1]=(pMeshEnt)F_exist(0,DEs[0],DEs[1],DEs[5],DEs[4]);
	faces[2]=(pMeshEnt)F_exist(0,DEs[1],DEs[2],DEs[6],DEs[5]);
	faces[3]=(pMeshEnt)F_exist(0,DEs[2],DEs[3],DEs[7],DEs[6]);
	faces[4]=(pMeshEnt)F_exist(0,DEs[3],DEs[0],DEs[4],DEs[7]);
	faces[5]=(pMeshEnt)F_exist(0,DEs[4],DEs[5],DEs[6],DEs[7]);
	new_ent=(pMeshEnt)M_createR(part, 6, faces, 0, geom_ent);
      } break;
   
      case mEntity::PRISM: 
      {
	numDE=6; 
	pMeshEnt faces[5];
	faces[0]=(pMeshEnt)F_exist(0,DEs[0],DEs[1],DEs[2],(pMeshEnt)NULL);
	faces[1]=(pMeshEnt)F_exist(0,DEs[0],DEs[1],DEs[4],DEs[3]);
	faces[2]=(pMeshEnt)F_exist(0,DEs[1],DEs[2],DEs[5],DEs[4]);
	faces[3]=(pMeshEnt)F_exist(0,DEs[2],DEs[0],DEs[3],DEs[5]);
	faces[4]=(pMeshEnt)F_exist(0,DEs[3],DEs[4],DEs[5],(pMeshEnt)NULL);
	new_ent=(pMeshEnt)M_createR(part, 5, faces, 0, geom_ent);
      } break; 

      case mEntity::PYRAMID: 
      {
	numDE=5; 

	pMeshEnt faces[5];
	faces[0]=(pMeshEnt)F_exist(0,DEs[0],DEs[1],DEs[2],DEs[3]);
	faces[1]=(pMeshEnt)F_exist(0,DEs[0],DEs[1],DEs[4],(pMeshEnt)0);
	faces[2]=(pMeshEnt)F_exist(0,DEs[1],DEs[2],DEs[4],(pMeshEnt)0);
	faces[3]=(pMeshEnt)F_exist(0,DEs[2],DEs[3],DEs[4],(pMeshEnt)0);
	faces[4]=(pMeshEnt)F_exist(0,DEs[3],DEs[0],DEs[4],(pMeshEnt)0);
	
	new_ent=(pMeshEnt)M_createR(part, 5, faces, 0, geom_ent);
      } break;

      default :
      {
        std::cerr<<__func__<<": PUMI FATAL ERROR - unsupported entity topology from src_part "<<src_partid<<"onto dest_part "<<dest_partid<<"\n";
        abort(); return 0;
      }
    }
    n_bytes += numDE*sizeof(pMeshEnt);
  }
#ifdef _DEBUG_
  std::cout<<__func__<<": src_part "<<src_partid<<", dest_part "<<dest_partid<<" created "<<PUMI_MeshEnt_StrID(new_ent)<<"(mem: "<<new_ent<<")\n";
#endif
// STEP 3: copy Remote Copies and p-classification
  std::set<int> res_parts;
  if (numRC>0)
  {
    int remote_partid;
    mEntity *RCs_ent;
    for (short int i=0; i < numRC; i++)
    {
      remote_partid = *(int*)((char*)msg_recv + n_bytes);
      n_bytes += sizeof(int);
      RCs_ent = *(pMeshEnt*)((char*)msg_recv + n_bytes);
      n_bytes += sizeof(pMeshEnt);
      new_ent->addRemoteCopy(remote_partid, RCs_ent);
      res_parts.insert(remote_partid);
    }  
  }
  res_parts.insert(src_partid);
  new_ent->setPClassification(part->getPartitionModel()->getPartitionEntity(res_parts));

  // for partition object entity, set weight
  if (new_ent->getLevel()==meshDim)
  {
    // get weight
    double weight;
    memcpy(&weight, (char*)msg_recv+n_bytes, sizeof(double)); //avoid alignment exception on BGP
    PUMI_MeshEnt_SetWeight(new_ent, weight); 
    n_bytes+=sizeof(double);
  } // if

  new_ent->attachInt (FMDB_Util::Instance()->getGhost(), src_partid); // mark entity as ghost
  ent_addGhost(new_ent, src_partid, sender_copy);
  entitiesToBounce.push_back(rc_struct_3(dest_partid, new_ent, src_partid, sender_copy));  
  *num_ghost += 1;
  return new_ent;
}

// ********************************************
void  printPtnObjToGhost (std::map<pMeshEnt, std::vector<pMeshEnt> >& brg_ghost_map)       
// ********************************************
{
  mEntity *brg_ent;
  for (std::map<pMeshEnt,std::vector<pMeshEnt> >::iterator mapit=brg_ghost_map.begin();
       mapit!= brg_ghost_map.end();++mapit)
  {
    brg_ent=mapit->first;
    
    for (std::vector<pMeshEnt>::iterator ghost_it=mapit->second.begin();ghost_it!=mapit->second.end(); ++ghost_it)
    {
      std::cout<<"("<<PUMI_CommRank()<<") ghost "<<PUMI_MeshEnt_StrID(*ghost_it)<<" (brg: "<<PUMI_MeshEnt_StrID(brg_ent)<<")\n";
    }
  }
}
#endif
