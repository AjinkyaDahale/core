\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage[margin=1.0in]{geometry}
\setcounter{MaxMatrixCols}{20}

\title{Error Indicators using Superconvergent Patch Recovery}
\author{Brian Granzow}

\begin{document}
\maketitle

\section{Introduction}
Error indication routines have been implemented in the Adaptive Parallel 
Fields (APF) library. The purpose of these routines is two-fold: (1) 
produce an indication of the error of a finite element solution over a 
finite element mesh and (2) produce a mesh size field based on the error 
indication as input for mesh adaptation. The current routines can operate
on scalar, vector, or second order tensor quantities defined at integration
points for simplical meshes with first or second order Lagrangian elements.

An indication of error is produced by first constructing a recovered 
solution using Super Convergent Patch Recovery (SPR). This recovered 
solution is assumed to be an interpolatory function of the shape functions
of the finite element mesh. Thus, once the recovered solution is known at
nodal locations, the field is well-defined over the entire mesh. The error 
is then defined as the difference between the finite element solution and 
the recovered solution.

\section{Overview}
From a high level, the error indication routines in APF carry out the
following steps: Given a $(p-1)$ tensor $\boldsymbol{\sigma}$ that is 
defined at integration points:
\begin{enumerate}
\item Construct an appropriate patch of elements
\item Recover a $p$-order field $\boldsymbol{\sigma}^*$ via 
a least squares fit over the element patch
\item Repeat steps 1 and 2 for all element patches in the mesh
\item Integrate norms of the $p$-order error field
or $\textbf{e}_\sigma = \boldsymbol{\sigma} - \boldsymbol{\sigma}^*$
over the whole mesh.
\item Compute an appropriate mesh size filed based on the estimated
error
\end{enumerate}

\section{Super Convergent Patch Recovery}

\subsection{Patch Construction}
The process for the initial construction of an element patch is 
straightforward. A central mesh entity $M^d_i$ of topological dimension $d$
with one or more nodes classified on it is chosen. The patch is then
defined as the set of mesh elements $\{M^d_i\{M^D\}\}$ adjacent to the 
central mesh entity $M^d_i$, where $D$ is the topological dimension of the
mesh.

\subsection{Patch Expansion}
Let $k$ be the total number of elements in a given element patch and $q$ be
the total number of integration points in each element. Then each element 
patch contains a total of $n = kq$ integration points. In certain scenarios
(discussed in \ref{ss:solve}), there are not enough integration points in
an element patch to recover the solution $\boldsymbol{\sigma}$ via a least
squares fit. In such scenarios, it is necessary to expand the element patch
to include additional elements. The following steps are carried out in
order until the patch contains enough integration points for the least
squares fit to be well defined:
\begin{itemize}
\item add elements adjacent to the faces of the patch
\item add elements adjacent to the edges of the patch
\item add elements adjacent to the vertices of the patch 
\end{itemize}

\subsection{Solution Recovery}
For each patch constructed, the data $\boldsymbol{\sigma}$ at integration 
points are used to produce a recovered solution $\boldsymbol{\sigma}^*$
at nodes classified on the central mesh entity of the element patch. Each
component $\sigma$ of $\boldsymbol{\sigma}$ is fit to a complete polynomial
of the form
 \[
\sigma^* = \textbf{p} \boldsymbol{\alpha}
\]
where for general $p$-order Lagrangian elements
\[
\textbf{p} = \left[ 1,x,y,z,xy,xz,yz,\cdots,x^p,y^p,z^p \right] 
\]
and 
\[
\boldsymbol{\alpha} = \left[ \alpha_1, \alpha_2, \cdots, \alpha_m \right]
\]
where
\[
m = \frac{(p+1)(p+2)(p+3)}{6}
\]
is the total number of unkown coefficients of the polynomial $\sigma^*$.

\subsection{Solving for Polynomial Coefficients}
\label{ss:solve}
The unknown coefficients $\boldsymbol{\alpha}$ of the least squares problem
are found by solving the normal equation
\[
\mathrm{P^TP} = \mathrm{P^T} \boldsymbol{\sigma^h} 
\]
where
\[
\begin{bmatrix}
\mathrm{P} = 
1 & x_1 & y_1 & z_1 & \cdots & x_1^p & y_1^p & z_1^p \\
1 & x_2 & y_2 & z_2 & \cdots & x_2^p & y_2^p & z_2^p \\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
1 & x_n & y_n & z_n & \cdots & x_n^p & y_n^p & z_n^p \\
\end{bmatrix}
\]
and
\[
\boldsymbol{\sigma}^h	=
\begin{bmatrix}
\sigma(\textbf{x}_1) \\
\sigma(\textbf{x}_2) \\
\vdots \\
\sigma(\textbf{x}_n) \\
\end{bmatrix}
\]
where $\textbf{x}_i = (x_i,y_i,z_i)$'s are the $n$ integration points in 
the element patch. The solution to the normal equations are found by 
singular value decomposition (SVD). As mentioned previously, if the total 
number of integration points $n$ in the element patch is less than $m$, 
the number of unknown polynomial coefficients, then the element patch must 
be expanded.

\subsection{Solving the Linear System via SVD}
The unknown coefficients $\boldsymbol{\alpha}$ of the least squares 
problem are found by solving a linear system of the form
\[
\mathrm{A} \boldsymbol{\alpha} = \textbf{b}
\]
This equation is solved via Singular Value Decomposition (SVD) of the 
matrix $\mathrm{A}$
\[
\mathrm{A} = \mathrm{U} \mathrm{W} \mathrm{V^T}
\]
where U,V $\in \mathbb{R}^{m \, x \, m}$ are orthonormal and 
W $\in \mathbb{R}^{m \, x \, m}$ is diagonal.
The solution is then
\[
\boldsymbol{\alpha} = \mathrm{V} 
\mathrm{W}^{-1} \mathrm{U^T} \textbf{b}
\]

\subsection{Timing}
For meshes with tetrahedral elements with linear Lagrange shape functions, 
there are nodes associated with each mesh vertex. For each mesh vertex, a 
4 x 4 linear system must be solved. If there are $n_v$ mesh vertices in the
mesh, then then there are $n_v$ linear systems of dimension 4 x 4 that need
to be solved.

For meshes with tetrahedral elements with quadratic Lagrange shape 
functions, there are one node associated with each mesh vertex and one
node associated with each mesh edge. For each mesh vertex and mesh edge, 
a 10 x 10 linear system must be solved. If there are $n_v$ mesh vertices
and $n_v$ mesh edges, then $n_v + n_e$ linear systems of dimension 10 x 10
need to be solved.

\section{Error Indication}
Once the interpolatory function $\boldsymbol{\sigma}^*$ has been
constructed via SPR, a notion of the error in the finite element solution
can be computed. This notion of error is called an error indicator rather
than an error estimator because an accurate upper bound of the real error
is not determined.

A per-element scalar error indicator $\|\textbf{e}_\sigma\|_e$ 
is computed using the integated difference between the finite element 
and recovered solution fields
\[
\textbf{e}_\sigma = \boldsymbol{\sigma - \sigma}^*
\]
where the norm $\|\cdot\|_e$ is defined as 
\[
\|\textbf{A}\|_e= \left( \int_{\Omega^e} 
\textbf{A} : \textbf{A} \, d\Omega \right)^\frac12
\]
for second order tensors quantities $\textbf{A}$, as
\[
\|\textbf{v}\|_e= \left( \int_{\Omega^e} 
\textbf{v} \cdot \textbf{v} \, d\Omega \right)^\frac12
\]
for vector quantities $\textbf{v}$, and as 
\[
\|s\|_e= \left( \int_{\Omega^e} 
s^2 \, d\Omega \right)^\frac12
\]
for scalar quantities $s$, where $\textbf{A}:\textbf{A}$ is the Frobenius 
inner product and $\textbf{v} \cdot \textbf{v}$ is the dot product. 
Similarly, a global norm $\|\cdot\|$ over the entire mesh is defined as
\[
\|\cdot\| = \left( \sum_{e=1}^{n_e} 
\| \cdot \|_e^2 \, d\Omega \right)^\frac12
\]

\section{Size Field Computation}
A per-element scalar size factor is computed based on the per-element 
error following this formula:
\[
h^\text{new}_e = h^\text{current}_e
\|\textbf{e}_\sigma\|^{-\frac{2}{2p+d}}_e
\left(
\frac
{\hat{\eta}^2\|\boldsymbol{\sigma}^*\|^2}
{\sum_{i=1}^n\|\textbf{e}_\sigma\|^\frac{2d}{2p+d}_i}
\right)^\frac{1}{2p}
\]
To which the following definitions apply:

\begin{center}
\begin{tabular}{ll}
$d$ & element dimension \\
$p$ & polynomial order of $f$ \\
$\eta$ & $\frac{\|e_\epsilon\|}{\|\epsilon\|}$ \\
$\hat{\eta}$ & threshold on $\eta$ for adaptivity \\
$n$ & number of elements in the mesh \\
$h_e^\text{current}$ & the current element size (longest edge) \\
$h_e^\text{new}$ & the desired element size for adaptivity \\
\end{tabular}
\end{center}

The idea is that such a size field will produce a mesh where the relative
error indication $\eta$ is less than a user-specified value $\hat{\eta}$.

MeshAdapt expects a linear size field, which in this case is isotropic, 
so the desired element size values must be converted into vertex size field
values. The current code simply averages the desired sizes of elements 
adjacent to a vertex.
 
\end{document}
