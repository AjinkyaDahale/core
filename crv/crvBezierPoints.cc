/*
 * Copyright 2015 Scientific Computation Research Center
 *
 * This work is open source software, licensed under the terms of the
 * BSD license as described in the LICENSE file in the top-level directory.
 */

#include "crvBezier.h"
#include "crvTables.h"
#include <cassert>

namespace crv {

void getBezierCurveNodeXi(int type, int P, int node, apf::Vector3& xi)
{
  static double eP2[1] = {0.0};
  static double eP3[2] = {-0.4306648,0.4306648};
  static double eP4[3] = {-0.6363260,0.0,0.6363260};
  static double eP5[4] = {-0.7485748,-0.2765187,0.2765187,0.7485748};
  static double eP6[5] = {-0.8161268,-0.4568660,0.0,
      0.4568660,0.8161268};

  static double* edgePoints[6] =
  {eP2, eP2, eP3, eP4, eP5, eP6 };

  if(type == apf::Mesh::EDGE && P > 1){
    xi[0] = edgePoints[P-1][node];
  } else {
    getBezierNodeXi(type,P,node,xi);
  }
}

void getBezierNodeXi(int type, int P, int node, apf::Vector3& xi)
{
  static double eP2[1] = {0.0};
  static double eP3[2] = {-0.4503914,0.4503914};
  static double eP4[3] = {-0.6612048,0.0,0.6612048};
  static double eP5[4] = {-0.7732854,-0.2863522,0.2863522,0.7732854};
  static double eP6[5] = {-0.8388042,-0.469821,0.0,
      0.469821,0.8388042};
  static double* edgePoints[6] =
  {eP2, eP2, eP3, eP4, eP5, eP6 };
  switch (type) {
  case apf::Mesh::EDGE:
    xi[0] = edgePoints[P-1][node];
    break;
  case apf::Mesh::TRIANGLE:
    // technically only two of these numbers are needed
    switch (P) {
    case 1:
    case 2:
      fail("expected P >= 3");
    case 3:
      xi = apf::Vector3(1./3.,1./3.,1./3.);
      break;
    case 4:
      xi[(node+2) % 3] = 0.5582239;
      xi[(node+0) % 3] = 0.22088805;
      xi[(node+1) % 3] = 0.22088805;
      break;
    case 5:
      static apf::Vector3 nodes5[6] =
      {apf::Vector3(0.15251715,0.15251715,0.6949657),
       apf::Vector3(0.4168658,0.1662684,0.4168658),
       apf::Vector3(0.6949657,0.15251715,0.15251715),
       apf::Vector3(0.1662684,0.4168658,0.4168658),
       apf::Vector3(0.4168658,0.4168658,0.1662684),
       apf::Vector3(0.15251715,0.6949657,0.15251715)};
      xi = nodes5[node];
      break;
    case 6:
      static apf::Vector3 nodes6[10] =
      {apf::Vector3(0.10971385,0.10971385,0.7805723),
       apf::Vector3(0.3157892,0.1256031,0.5586077),
       apf::Vector3(0.5586077,0.1256031,0.3157892),
       apf::Vector3(0.7805723,0.10971385,0.10971385),
       apf::Vector3(0.1256031,0.3157892,0.5586077),
       apf::Vector3(1./3.,1./3.,1./3.),
       apf::Vector3(0.5586077,0.3157892,0.1256031),
       apf::Vector3(0.1256031,0.5586077,0.3157892),
       apf::Vector3(0.3157892,0.5586077,0.1256031),
       apf::Vector3(0.10971385,0.7805723,0.10971385)};
      xi = nodes6[node];
      break;
    }
    break;
  case apf::Mesh::TET:
    switch (P) {
    case 1:
    case 2:
    case 3:
      fail("expected P == 4");
    case 4:
      xi = apf::Vector3(0.25,0.25,0.25);
      break;
    case 5:
    case 6:
      fail("expected P == 4");
    }
    break;
    default:
      xi.zero();
      break;
  }
}

static void getBezierCurveTransform(int P, apf::NewArray<double> & c)
{
  double e2[3] = {-0.5,-0.5,2};
  double e3[8] = {
      -0.970273514083553,0.333333333333333,2.71895067382449,-1.08201049307427,
      0.333333333333333,-0.970273514083553,-1.08201049307427,2.71895067382449};
  double e4[15] = {
      -1.4304202857228,-0.25,3.39545839723405,-1.46967987431139,
      0.754641762800137,0.953613523815196,0.953613523815197,-2.76673344002279,4.62623983241519,
      -2.76673344002279,-0.25,-1.4304202857228,0.754641762800137,-1.46967987431139,
      3.39545839723405};
  double e5[24] = {
      -1.88592269024942,0.2,4.05614415979432,-1.81653638123435,
      1.0295423816296,-0.583227469940158,1.85476912333284,-0.942961345124708,-5.01939997635205,6.96205913930752,
      -4.56234099538677,2.70787405422317,-0.942961345124708,1.85476912333285,2.70787405422317,-4.56234099538677,
      6.96205913930752,-5.01939997635206,0.2,-1.88592269024942,-0.583227469940158,1.0295423816296,
      -1.81653638123435,4.05614415979432};
  double e6[35] = {
      -2.33890800235808,-0.166666666666667,4.70907763497668,-2.14695478588352,
      1.2670886004356,-0.80040589915343,0.476769118649422,3.03457283388393,
      0.935563200943235,-7.82909978199834,9.74813267975089,
      -6.60581336123903,4.37362214799981,-2.65697771934049,-2.27592962541295,
      -2.27592962541295,6.3088040999163,-9.70710791530195,
      12.3484668815972,-9.70710791530194,6.3088040999163,0.935563200943235,
      3.03457283388393,-2.65697771934049,4.37362214799981,
      -6.60581336123903,9.74813267975088,-7.82909978199834,-0.166666666666667,
      -2.33890800235809,0.476769118649422,-0.80040589915343,
      1.2670886004356,-2.14695478588352,4.70907763497668};
  double* table[5] = {
      e2,e3,e4,e5,e6};
  int nb = P-1;
  int ni = P+1;
  c.allocate(ni*nb);
  for( int i = 0; i < nb; ++i)
    for( int j = 0; j < ni; ++j)
      c[i*ni+j] = table[P-2][i*ni+j];

}
static void getBezierEdgeTransform(int P, apf::NewArray<double> & c)
{
  double e2[3] = {-0.5,-0.5,2};
  double e3[8] = {
      -1.00596379148431,0.333333333333333,2.69317845753742,-1.02054799938644,
      0.333333333333333,-1.00596379148431,-1.02054799938644,2.69317845753742};
  double e4[15] = {
      -1.52680420766155,-0.25,3.37567603341243,-1.28732567375034,
      0.688453847999458,1.01786947177436,1.01786947177436,-2.70941992094126,4.38310089833379,
      -2.70941992094126,-0.25,-1.52680420766155,0.688453847999459,-1.28732567375034,
      3.37567603341243};
  double e5[24] = {
      -2.06136018481524,0.2,4.05936188849008,-1.52513018373641,
      0.846118038541145,-0.518989558479574,2.07392858296555,-1.03068009240762,
      -5.04403528329688,6.4850808350761,-4.1256786562572,2.64138461392004,
      -1.03068009240762,2.07392858296555,2.64138461392004,-4.1256786562572,
      6.48508083507611,-5.04403528329688,0.2,-2.06136018481524,-0.518989558479574,
      0.846118038541145,-1.52513018373641,4.05936188849008};
  double e6[35] = {
      -2.60465921875445,-0.166666666666667,4.74317259573776,-1.74847211573074,
      0.99151406014263,-0.630691218757935,0.415802564029398,3.50945493261743,
      1.04186368750178,-8.00777336834505,8.99109434126308,
      -5.80152934540333,3.85156704410589,-2.5846772917398,-2.63209119946307,
      -2.63209119946307,6.39664544713349,-8.91824703868012,
      11.3073855820194,-8.91824703868012,6.39664544713349,1.04186368750178,
      3.50945493261743,-2.5846772917398,3.85156704410589,
      -5.80152934540333,8.99109434126308,-8.00777336834505,-0.166666666666667,
      -2.60465921875445,0.415802564029398,-0.630691218757935,
      0.991514060142631,-1.74847211573074,4.74317259573777};

  double* table[5] = {
      e2,e3,e4,e5,e6};

  int nb = P-1;
  int ni = P+1;
  c.allocate(ni*nb);
  for( int i = 0; i < nb; ++i)
    for( int j = 0; j < ni; ++j)
      c[i*ni+j] = table[P-2][i*ni+j];
}

static void getBezierTriangleTransform(int P, apf::NewArray<double> & c)
{
  double f3[10] = {
      0.5059637914843115,0.5059637914843116,0.5059637914843119,-0.8363152290754889,
      -0.8363152290754891,-0.8363152290754891,-0.8363152290754897,-0.8363152290754891,
      -0.8363152290754898,4.5};
  double f4[45] = {
      1.473866405971784,-0.4873245458152482,-0.4873245458152483,-2.157170326583087,
      -0.7895371825786641,1.002268609355065,0.4569922360188257,0.4160673296503333,
      0.4569922360188257,1.002268609355065,-0.7895371825786643,-2.157170326583087,
      7.066481928037422,-2.00343662222666,-2.00343662222666,
      -0.4873245458152483,1.473866405971784,-0.4873245458152482,1.002268609355065,
      -0.7895371825786646,-2.157170326583087,-2.157170326583087,-0.7895371825786643,
      1.002268609355065,0.4569922360188255,0.4160673296503333,0.4569922360188255,
      -2.00343662222666,7.066481928037421,-2.00343662222666,
      -0.4873245458152483,-0.4873245458152481,1.473866405971784,0.4569922360188258,
      0.4160673296503332,0.4569922360188255,1.002268609355065,-0.7895371825786646,
      -2.157170326583087,-2.157170326583088,-0.7895371825786643,1.002268609355065,
      -2.00343662222666,-2.00343662222666,7.066481928037422};
  double f5[126] = {
      2.955509375394109,0.4850633218816852,0.4850633218816842,-4.015153971419449,
      -0.6339185304220426,1.140973028173455,-1.041278651590121,-0.3192965376117991,
      -0.2178043751582104,-0.2178043751582106,-0.3192965376117977,-1.041278651590119,
      1.140973028173454,-0.6339185304220449,-4.015153971419449,10.16896081482358,
      -3.086925777444235,1.177507607441265,-3.086925777444229,0.8971975820812144,
      1.177507607441261,
      -1.879829564696171,-1.879829564696172,0.5695483481139592,3.558924203285689,
      -2.437779912677449,-2.437779912677447,3.558924203285689,1.772590081128005,
      0.9751122788728834,0.114906885694974,-0.8337418650640221,-0.8337418650640223,
      0.1149068856949739,0.975112278872884,1.772590081128002,-6.137619043989808,
      12.47852594090007,-6.137619043989812,-2.280366067778762,-2.280366067778761,
      2.247531721435297,
      0.4850633218816853,2.955509375394109,0.4850633218816858,-1.041278651590121,
      1.140973028173455,-0.6339185304220443,-4.015153971419449,-4.01515397141945,
      -0.6339185304220427,1.140973028173454,-1.041278651590121,-0.3192965376118004,
      -0.2178043751582095,-0.2178043751582098,-0.3192965376117998,1.177507607441266,
      -3.086925777444232,10.16896081482358,0.8971975820812099,-3.086925777444233,
      1.177507607441266,
      -1.879829564696168,0.5695483481139586,-1.879829564696167,1.772590081128001,
      0.9751122788728822,0.1149068856949737,-0.8337418650640216,-0.8337418650640215,
      0.1149068856949736,0.9751122788728837,1.772590081127999,3.558924203285684,
      -2.437779912677445,-2.437779912677444,3.558924203285684,-6.137619043989801,
      -2.280366067778758,2.247531721435295,12.47852594090005,-2.28036606777876,
      -6.1376190439898,
      0.5695483481139563,-1.87982956469617,-1.879829564696174,-0.8337418650640195,
      0.114906885694975,0.9751122788728848,1.772590081128002,3.55892420328569,
      -2.437779912677449,-2.437779912677447,3.558924203285693,1.772590081128009,
      0.9751122788728801,0.1149068856949706,-0.8337418650640169,2.247531721435288,
      -2.280366067778765,-6.137619043989809,-2.280366067778744,12.47852594090007,
      -6.137619043989821,
      0.4850633218816849,0.485063321881685,2.955509375394111,-0.3192965376117988,
      -0.2178043751582104,-0.2178043751582108,-0.3192965376117985,-1.041278651590121,
      1.140973028173456,-0.6339185304220445,-4.01515397141945,-4.015153971419451,
      -0.6339185304220428,1.140973028173455,-1.04127865159012,1.177507607441264,
      0.897197582081215,1.177507607441264,-3.086925777444235,-3.086925777444234,
      10.16896081482358};
  double f6[280] = {
      4.990795106388402,-0.4798837984147304,-0.4798837984147311,-6.458245423578353,
      -0.3639631629214184,1.223365632584435,-1.237281132017871,1.048637951819914,
      0.2399023612066779,0.1476405704559403,0.09371675625976672,0.1476405704559403,
      0.2399023612066771,1.048637951819915,-1.237281132017874,1.22336563258444,
      -0.3639631629214241,-6.458245423578351,13.89283735202937,-4.276280903149718,
      1.808916611395359,-0.815238923186442,-4.276280903149713,1.327623829722842,
      -0.4900563063939837,1.808916611395356,-0.4900563063939835,-0.81523892318644,
      -4.689458981957332,2.303409358216716,-0.6686820957216246,8.401259643873194,
      -5.32764003589759,-2.380733253738298,4.596086431435173,-4.676887162735884,
      -1.613859854887052,-0.8313011663168198,-0.353269505070007,0.01692167342425344,
      0.783807813660766,1.115432125134819,-0.6396258416621945,-0.4063403163659929,
      1.63350774282936,4.420179509817762,-13.10100871536224,20.0696850984568,
      -10.70127780752898,5.237779423093969,-2.093285349716033,-4.18119984946875,
      2.406990467529693,3.071067981878368,0.7247013815918737,-2.116258714513938,
      2.303409358216713,-4.689458981957323,-0.6686820957216264,-4.676887162735882,
      4.596086431435173,-2.380733253738303,-5.327640035897582,8.40125964387318,
      4.420179509817754,1.633507742829359,-0.4063403163659948,-0.6396258416621916,
      1.115432125134818,0.7838078136607716,0.01692167342424611,-0.3532695050700018,
      -0.8313011663168233,-1.613859854887048,5.237779423093964,-10.70127780752897,
      20.06968509845678,-13.10100871536223,2.40699046752969,-4.181199849468755,
      -2.093285349716027,0.7247013815918821,3.071067981878365,-2.116258714513939,
      -0.4798837984147314,4.990795106388401,-0.4798837984147301,1.048637951819916,
      -1.237281132017876,1.22336563258444,-0.3639631629214218,-6.458245423578349,
      -6.458245423578349,-0.3639631629214216,1.223365632584435,-1.237281132017871,
      1.048637951819913,0.2399023612066772,0.1476405704559403,0.09371675625976489,
      0.1476405704559418,0.2399023612066772,-0.8152389231864428,1.808916611395362,
      -4.276280903149718,13.89283735202936,-0.4900563063939837,1.327623829722837,
      -4.276280903149709,-0.4900563063939801,1.808916611395357,-0.8152389231864411,
      -4.689458981957326,-0.6686820957216243,2.303409358216713,4.420179509817762,
      1.633507742829353,-0.4063403163659914,-0.6396258416621946,1.115432125134818,
      0.7838078136607659,0.01692167342425165,-0.3532695050700053,-0.8313011663168223,
      -1.613859854887046,-4.676887162735882,4.596086431435175,-2.380733253738309,
      -5.327640035897575,8.401259643873182,-13.10100871536224,-2.093285349716022,
      3.071067981878363,-2.116258714513934,20.06968509845678,-4.181199849468753,
      0.7247013815918747,-10.70127780752897,2.406990467529694,5.237779423093959,
      2.740410900541122,2.740410900541103,2.740410900541114,-3.896719679725162,
      0.8525687056196811,2.629196981978401,0.8525687056196632,-3.896719679725137,
      -3.896719679725126,0.8525687056196491,2.629196981978421,0.8525687056196478,
      -3.896719679725137,-3.896719679725156,0.8525687056196771,2.629196981978398,
      0.8525687056196591,-3.89671967972515,9.218530840490791,-7.999447648758395,
      -7.999447648758339,9.218530840490757,-7.999447648758336,23.49717556815216,
      -7.999447648758354,-7.999447648758379,-7.999447648758353,9.218530840490786,
      -0.6686820957216238,-4.689458981957319,2.303409358216712,1.115432125134813,
      -0.6396258416621886,-0.4063403163659943,1.633507742829352,4.420179509817753,
      8.401259643873173,-5.327640035897578,-2.380733253738297,4.59608643143517,
      -4.676887162735879,-1.61385985488705,-0.8313011663168175,-0.35326950507,
      0.01692167342424691,0.7838078136607683,-2.116258714513931,3.071067981878351,
      -2.093285349716015,-13.10100871536222,0.7247013815918777,-4.181199849468735,
      20.06968509845676,2.406990467529674,-10.70127780752897,5.237779423093965,
      2.303409358216709,-0.6686820957216228,-4.689458981957325,-1.613859854887044,
      -0.8313011663168245,-0.3532695050700039,0.01692167342424997,0.7838078136607665,
      1.115432125134813,-0.6396258416621888,-0.406340316365999,1.633507742829364,
      4.420179509817753,8.401259643873189,-5.327640035897586,-2.380733253738296,
      4.596086431435168,-4.676887162735876,5.237779423093958,2.406990467529699,
      0.724701381591874,-2.116258714513933,-10.70127780752898,-4.181199849468753,
      3.071067981878364,20.06968509845678,-2.093285349716028,-13.10100871536224,
      -0.6686820957216243,2.303409358216713,-4.689458981957323,0.7838078136607708,
      0.01692167342424194,-0.353269505069999,-0.8313011663168179,-1.613859854887048,
      -4.676887162735883,4.596086431435175,-2.380733253738307,-5.327640035897575,
      8.401259643873177,4.420179509817762,1.633507742829345,-0.4063403163659917,
      -0.6396258416621861,1.115432125134812,-2.11625871451393,0.724701381591889,
      2.40699046752967,5.237779423093964,3.07106798187834,-4.181199849468741,
      -10.70127780752897,-2.093285349716002,20.06968509845677,-13.10100871536223,
      -0.4798837984147306,-0.4798837984147314,4.990795106388401,0.2399023612066765,
      0.1476405704559429,0.09371675625976505,0.1476405704559399,0.2399023612066777,
      1.048637951819916,-1.237281132017875,1.223365632584441,-0.3639631629214257,
      -6.458245423578348,-6.458245423578355,-0.3639631629214177,1.223365632584434,
      -1.237281132017873,1.048637951819915,-0.8152389231864428,-0.4900563063939873,
      -0.4900563063939785,-0.8152389231864419,1.808916611395365,1.327623829722838,
      1.808916611395357,-4.276280903149721,-4.276280903149711,13.89283735202937
  };
  double* table[4] = {f3,f4,f5,f6};
  int nb = curved_face_internal[BEZIER][P-1];
  int ni = curved_face_total[BEZIER][P-1];
  c.allocate(ni*nb);
  for( int i = 0; i < nb; ++i)
    for( int j = 0; j < ni; ++j)
      c[i*ni+j] = table[P-3][i*ni+j];
}

static void getBezierTetTransform(int P, apf::NewArray<double> & c)
{
  assert(P == 4 && getBlendingOrder() == 0);
  double t4[35] = {
      -0.665492638178598,-0.665492638178598,-0.665492638178598,-0.665492638178598,
      0.697909481209196,0.496340368840329,0.697909481209197,0.697909481209196,
      0.496340368840329,0.697909481209196,0.697909481209196,0.49634036884033,
      0.697909481209196,0.697909481209196,0.496340368840329,0.697909481209196,
      0.697909481209196,0.496340368840329,0.697909481209196,0.697909481209196,
      0.496340368840329,0.697909481209196,-1.52980434179205,-1.52980434179205,
      -1.52980434179205,-1.52980434179205,-1.52980434179205,-1.52980434179205,
      -1.52980434179205,-1.52980434179205,-1.52980434179205,-1.52980434179205,
      -1.52980434179205,-1.52980434179205,10.6666666666667,
  };

  int nb = curved_tet_internal[BEZIER][P-1];
  int ni = curved_tet_total[BEZIER][P-1];

  c.allocate(ni*nb);
  for( int i = 0; i < nb; ++i)
    for( int j = 0; j < ni; ++j)
      c[i*ni+j] = t4[i*ni+j];
}
void getTransformationCoefficients(int dim, int P, int type,
    apf::NewArray<double>& c){
  if(dim == 2 && getBlendingOrder() > 0)
    getBezierCurveTransform(P,c);
  else if(type == apf::Mesh::EDGE)
    getBezierEdgeTransform(P,c);
  else if(type == apf::Mesh::TRIANGLE)
    getBezierTriangleTransform(P,c);
  else if(type == apf::Mesh::TET)
    getBezierTetTransform(P,c);
}

static void getGregoryTriangleTransform(int P, apf::NewArray<double> & c)
{
  apf::NewArray<double> d;
  getBezierTriangleTransform(P,d);

  int nbBezier = curved_face_internal[BEZIER][P-1];
  int niBezier = curved_face_total[BEZIER][P-1];

  int nb = curved_face_internal[GREGORY][P-1];
  int ni = curved_face_total[GREGORY][P-1];
  c.allocate(ni*nb);

  int map[3] = {1,2,0};
  // copy the bezier point locations
  for(int i = 0; i < nbBezier; ++i){
    for(int j = 0; j < niBezier; ++j)
      c[i*ni+j] = d[i*niBezier+j];
    for(int j = niBezier; j < ni; ++j)
      c[i*ni+j] = 0.;
  }
  if(P == 3){
    for(int i = nbBezier; i < nb; ++i){
      for(int j = 0; j < niBezier; ++j)
        c[i*ni+j] = d[j];
      for(int j = niBezier; j < ni; ++j)
        c[i*ni+j] = 0.;
    }
  }
  if(P == 4){
    for(int i = nbBezier; i < nb; ++i){
      for(int j = 0; j < niBezier; ++j)
        c[i*ni+j] = d[map[i-nbBezier]*niBezier+j];
      for(int j = niBezier; j < ni; ++j)
        c[i*ni+j] = 0.;
    }
  }
}

static void getGregoryTetTransform(int P, apf::NewArray<double> & c)
{
  assert(P == 4 && getBlendingOrder() == 0);
  double t4[47] = {
      -0.665492638178598,-0.665492638178598,-0.665492638178598,-0.665492638178598,
      0.697909481209196,0.496340368840329,0.697909481209197,0.697909481209196,
      0.496340368840329,0.697909481209196,0.697909481209196,0.49634036884033,
      0.697909481209196,0.697909481209196,0.496340368840329,0.697909481209196,
      0.697909481209196,0.496340368840329,0.697909481209196,0.697909481209196,
      0.496340368840329,0.697909481209196,
      -1.52980434179205,-1.52980434179205,-1.52980434179205,0.,0.,0.,
      -1.52980434179205,-1.52980434179205,-1.52980434179205,0.,0.,0.,
      -1.52980434179205,-1.52980434179205,-1.52980434179205,0.,0.,0.,
      -1.52980434179205,-1.52980434179205,-1.52980434179205,0.,0.,0.,
      10.6666666666667,
  };

  int nb = curved_tet_internal[GREGORY][P-1];
  int ni = curved_tet_total[GREGORY][P-1];

  c.allocate(ni*nb);
  for( int i = 0; i < nb; ++i)
    for( int j = 0; j < ni; ++j)
      c[i*ni+j] = t4[i*ni+j];
}

void getGregoryTransformationCoefficients(int /*dim*/, int P, int type,
    apf::NewArray<double>& c){
  assert(P == 3 || P == 4);
  if(type == apf::Mesh::EDGE)
    getBezierEdgeTransform(P,c);
  else if(type == apf::Mesh::TRIANGLE)
    getGregoryTriangleTransform(P,c);
  else if(type == apf::Mesh::TET)
    getGregoryTetTransform(P,c);
}

void getTransformationMatrix(apf::FieldShape* fs, int type,
    apf::DynamicMatrix& A)
{
  apf::Vector3 const edge_vert_xi[2] = {
    apf::Vector3(-1,0,0),
    apf::Vector3(1,0,0),
  };
  apf::Vector3 const tri_vert_xi[3] = {
    apf::Vector3(0,0,0),
    apf::Vector3(1,0,0),
    apf::Vector3(0,1,0),
  };
  apf::Vector3 const tet_vert_xi[4] = {
    apf::Vector3(0,0,0),
    apf::Vector3(1,0,0),
    apf::Vector3(0,1,0),
    apf::Vector3(0,0,1),
  };
  apf::Vector3 const* const elem_vert_xi[apf::Mesh::TYPES] = {
    0, /* vertex */
    edge_vert_xi,
    tri_vert_xi,
    0, /* quad */
    tet_vert_xi,
    0, /* hex */
    0, /* prism */
    0  /* pyramid */
  };

  setBlendingOrder(0); // makes sure blending is turned off.
  apf::EntityShape* es = fs->getEntityShape(type);
  int n = es->countNodes();
  int typeDim = apf::Mesh::typeDimension[type];

  apf::Vector3 xi, exi;
  int evi = 0;
  apf::NewArray<double> values;

  A.setSize(n,n);

  int boundaryTypes[4] = {apf::Mesh::VERTEX,apf::Mesh::EDGE,
      apf::Mesh::TRIANGLE,apf::Mesh::TET};

  int row = 0;
  for(int d = 0; d <= typeDim; ++d){
    int nDown = apf::Mesh::adjacentCount[type][d];
    for(int j = 0; j < nDown; ++j){
      int bt = boundaryTypes[d];
      apf::EntityShape* shape = apf::getLagrange(1)->getEntityShape(bt);

      for(int x = 0; x < fs->countNodesOn(bt); ++x){
        fs->getNodeXi(bt,x,xi);
        apf::NewArray<double> shape_vals;
        shape->getValues(0, 0, xi, shape_vals);

        if(d < typeDim){
          exi.zero();
          evi = j;
          for (int i = 0; i < apf::Mesh::adjacentCount[bt][0]; ++i) {
            if(bt == apf::Mesh::EDGE && type == apf::Mesh::TRIANGLE)
              evi = apf::tri_edge_verts[j][i];
            if(bt == apf::Mesh::EDGE && type == apf::Mesh::TET)
              evi = apf::tet_edge_verts[j][i];
            if(bt == apf::Mesh::TRIANGLE && type == apf::Mesh::TET)
              evi = apf::tet_tri_verts[j][i];
            assert(evi >= 0);
            exi += elem_vert_xi[type][evi] * shape_vals[i];
          }
        } else {
          exi = xi;
        }
        es->getValues(0,0,exi,values);
        for(int i = 0; i < n; ++i){
          A(row,i) = values[i];
        }
        ++row;
      }
    }
  }
}

} // namespace crv
